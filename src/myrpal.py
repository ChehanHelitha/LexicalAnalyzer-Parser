# Description:
# This script serves as the main entry point for interpreting RPAL programs. It provides functionality to interpret RPAL code, print Abstract Syntax Trees (ASTs), tokens, and filtered tokens, as well as execute the original RPAL interpreter on a file and print the AST.

# Usage:
# python myrpal.py [-ast] [-t] [-ft] [-st] [-r] [-rast] [-ct] file_name

# Arguments:
# file_name: The name of the RPAL file to interpret.

# Optional Switches:
# -ast: Print the Abstract Syntax Tree (AST) for the given RPAL program.
# -t: Print the tokens generated by the lexical analyzer for the given RPAL program.
# -ft: Print the filtered tokens generated by the screener for the given RPAL program.
# -st: Print the Standard Tree for the given RPAL program. (Not yet implemented)
# -r: Execute the original RPAL interpreter on the given RPAL program file (file should be in rpal_tests/rpal_source).
# -rast: Execute the original RPAL interpreter on the given RPAL program file and print the AST. (file should be in rpal_tests/rpal_source)
# -ct : Print the cse table for the given RPAL program.
# -l : Print the source code for the given RPAL program.
# -n: Default behavior, evaluate the program and print the output.

# Examples:
# To interpret an RPAL program:
# python myrpal.py file_name

# Optional Switches Examples:
# -t: python myrpal.py -t file_name
# -ft: python myrpal.py -ft file_name
# -ast: python myrpal.py -ast file_name
# -st: python myrpal.py -st file_name
# -r: python myrpal.py -r file_name
# -rast: python myrpal.py -rast file_name
# -rst: python myrpal.py -rst file_name
# -ct: python myrpal.py -ct file_name
# -l: python myrpal.py -l file_name
# -n: python myrpal.py -n file_name

import sys
import platform
import subprocess # Import the subprocess module
import os         # Import os for path manipulation

from interpreter.interpreter import Evaluator

def main():
    """
    Main function of the interpreter.

    Args:
        sys.argv (list): Command line arguments passed to the interpreter.

    Returns:
        None

    Raises:
        ValueError: If the number of command line arguments is less than 2.

    """

    # Check if there are enough command-line arguments
    if len(sys.argv) < 2:
        print("[Version 1.0 by Chehan & Eshin 4/19/2025]")
        print("Usage: python main.py [-ast] [-t] [-ft] [-st] [-r] [-rast] [-ct] [-l] [-noout] file_name ")
        return

    # Get the filename from the command-line arguments
    if len(sys.argv) >= 4:
        file_name = sys.argv[3]
    elif len(sys.argv) >= 3:
        file_name = sys.argv[2]
    else:
        file_name = sys.argv[1]

    # Create an instance of the Evaluator class
    evaluator = Evaluator()

    # Interpret the file
    evaluator.interpret(file_name)

    # Check if the -ast switch is provided
    if len(sys.argv) >= 4:
        if sys.argv[1] == "-ast" and sys.argv[2] == "-st":
            handle_ast_option(evaluator)
            handle_st_option(evaluator)
            handle_default_behavior(evaluator)
        elif sys.argv[1] == "-st" and sys.argv[2] == "-ast":
            handle_ast_option(evaluator)
            handle_st_option(evaluator)
            handle_default_behavior(evaluator)
    elif len(sys.argv) >= 3:
        if sys.argv[1] == "-ast":
            # Print the Abstract Syntax Tree
            handle_ast_option(evaluator)
            handle_default_behavior(evaluator)
        elif sys.argv[1] == "-t":
            # Print the tokens
            handle_tokens_option(evaluator)
            handle_default_behavior(evaluator)
        elif sys.argv[1] == "-ft":
            # Print the filtered tokens
            handle_filtered_tokens_option(evaluator)
            handle_default_behavior(evaluator)
        elif sys.argv[1] == "-st":
            # Print the standard tree
            handle_st_option(evaluator)
            handle_default_behavior(evaluator)

        elif sys.argv[1] == "-r":
            # Print the original RPAL evaluation
            try:
                handle_original_rpal_eval(file_name)
            except:
                print("Error in original RPAL evaluation\n(file should be in rpal_source folder)")
        elif sys.argv[1] == "-rast":
            # Print the original RPAL evaluation and AST
            try:
                handle_original_rpal_ast(file_name)
            except:
                print(
                    "Error in original RPAL evaluation\n(file should be in rpal_source file)")
        elif sys.argv[1] == "-rst":
            # Print the original RPAL evaluation and ST
            try:
                handle_original_rpal_st(file_name)
            except:
                print("Error in original RPAL evaluation\n(file should be in rpal_source file)")
        elif sys.argv[1] == "-ct":
            # Print the CSE table
            try:
                handle_cse_table_option(evaluator)
                handle_default_behavior(evaluator)
            except:
                print("Error in printing CSE table")
        elif sys.argv[1] == "-l":
            # Print the lexical analysis
            handle_get_source_code(evaluator)
            handle_default_behavior(evaluator)
        elif sys.argv[1] == "-n":
            handle_default_behavior(evaluator)

    else:
        # Default behavior: Evaluate the program
        handle_default_behavior(evaluator)

################################################################################################
# switch handlers for different options for different switches in the command line arguments 
################################################################################################

def handle_ast_option(evaluator):
    """
    Prints the Abstract Syntax Tree for the given file.

    Args:
        evaluator (Evaluator): An instance of the Evaluator class.

    Returns:
        None

    """
    # Your code to print the abstract syntax tree
    evaluator.print_AST()


def handle_st_option(evaluator):
    """
    Prints the Standard Tree for the given file.

    Args:
        evaluator (Evaluator): An instance of the Evaluator class.

    Returns:
        None

    """
    # Your code to print the standard tree
    evaluator.print_ST()


def handle_default_behavior(evaluator):
    """
    Prints the default behavior for the given file.

    Args:
        evaluator (Evaluator): An instance of the Evaluator class.

    Returns:
        None

    """
    # Your code for default behavior
    evaluator.print_output()


def handle_tokens_option(evaluator):
    """
    Prints the tokens for the given file.

    Args:
        evaluator (Evaluator): An instance of the Evaluator class.

    Returns:
        None

    """
    # Your code to print the tokens
    evaluator.print_tokens()


def handle_filtered_tokens_option(evaluator):
    """
    Prints the filtered tokens for the given file.

    Args:
        evaluator (Evaluator): An instance of the Evaluator class.

    Returns:
        None

    """
    # Your code to print the filtered tokens
    evaluator.print_filtered_tokens()


def get_rpal_exe_path():
    """
    Determines the path to rpal.exe.
    Adjust this function based on where rpal.exe is located.
    """
    # Example: Assume rpal.exe is in a directory 'rpal_executables'
    # one level up from the 'src' directory where myrpal.py might be.
    script_dir = os.path.dirname(os.path.abspath(__file__)) # Directory of myrpal.py (src)
    project_root = os.path.dirname(script_dir)             # One level up (your_project_directory)
    exe_path = os.path.join(project_root, "rpal_executables", "rpal.exe")

    # Alternative: if rpal.exe is directly in the system PATH:
    # exe_path = "rpal.exe" # The OS will search for it

    if not os.path.exists(exe_path):
        # Fallback if not found, perhaps it's in the current working directory or src
        local_exe_path = os.path.join(script_dir, "rpal.exe")
        if os.path.exists(local_exe_path):
            return local_exe_path
        # Add more search logic if needed or raise an error
        print(f"Error: rpal.exe not found at expected location: {exe_path}", file=sys.stderr)
        return None
    return exe_path

def run_external_rpal(rpal_file_path, options=None):
    """
    Runs the external rpal.exe with the given file and options.
    The rpal_file_path should be the path to the .rpal test file.
    """
    rpal_exe_location = get_rpal_exe_path()
    if not rpal_exe_location:
        return # rpal.exe not found

    command = [rpal_exe_location]
    if options:
        command.extend(options) # e.g., ['-ast']
    command.append(rpal_file_path)

    print(f"Executing: {' '.join(command)}", file=sys.stderr) # For debugging

    try:
        # The directory containing rpal.exe (and cygwin1.dll) should ideally be
        # in the system PATH, or you can set the working directory for the subprocess.
        # Setting cwd might help rpal.exe find cygwin1.dll if they are in the same dir.
        process = subprocess.run(command, capture_output=True, text=True, check=True,
                                 cwd=os.path.dirname(rpal_exe_location) if rpal_exe_location != "rpal.exe" else None)
        print(process.stdout, end='') # Print the output of rpal.exe
        if process.stderr:
            print("--- rpal.exe stderr ---", file=sys.stderr)
            print(process.stderr, file=sys.stderr)
            print("-----------------------", file=sys.stderr)

    except subprocess.CalledProcessError as e:
        print(f"Error running rpal.exe for {rpal_file_path}:", file=sys.stderr)
        print(f"Return code: {e.returncode}", file=sys.stderr)
        print(f"Stdout:\n{e.stdout}", file=sys.stderr)
        print(f"Stderr:\n{e.stderr}", file=sys.stderr)
    except FileNotFoundError:
        print(f"Error: '{rpal_exe_location}' not found or not executable. Make sure it's in your PATH or the path is correct.", file=sys.stderr)
    except Exception as e:
        print(f"An unexpected error occurred while running rpal.exe: {e}", file=sys.stderr)


# ... (rest of your main() and handler functions) ...

def handle_original_rpal_eval(rpal_test_file_path): # Renamed arg for clarity
    """
    Handles the original RPAL evaluation.
    Args:
        rpal_test_file_path (str): The path to the .rpal file to evaluate.
    """
    if platform.system() == "Windows":
        run_external_rpal(rpal_test_file_path) # Call the new runner function
    else:
        print("Original RPAL evaluation via rpal.exe is typically Windows-specific.")
        print("If you have a non-Windows version, adjust 'run_external_rpal'.")

def handle_original_rpal_ast(rpal_test_file_path):
    """
    Handles the original RPAL AST generation.
    """
    if platform.system() == "Windows":
        run_external_rpal(rpal_test_file_path, options=["-ast"])
    else:
        print("Original RPAL AST generation via rpal.exe is typically Windows-specific.")

def handle_original_rpal_st(rpal_test_file_path):
    """
    Handles the original RPAL ST generation.
    """
    if platform.system() == "Windows":
        run_external_rpal(rpal_test_file_path, options=["-st"])
    else:
        print("Original RPAL ST generation via rpal.exe is typically Windows-specific.")

def handle_cse_table_option(evaluator):
    """
    Prints the CSE table for the given file.

    Args:
        evaluator (Evaluator): An instance of the Evaluator class.

    Returns:
        None

    """
    # Your code to print the CSE table
    evaluator.print_cse_table()

def handle_get_source_code(evaluator):
    """
    Prints the source code for the given file.

    Args:
        evaluator (Evaluator): An instance of the Evaluator class.

    Returns:
        None

    """
    # Your code to print the source code
    print(evaluator.str_content,end="")


if __name__ == "__main__":
    main()